//비트코인은 신이고 나는 무적이다(23257)

//이전 N개의 월봉을 통해, 다음 월봉의 절댓값을 예측해보자.
//(다음 월봉의 절댓값) = 이전 N개의 월봉 중 중복을 허용해 M개를 골라, 절댓값들을 bitwise xor한 것 중 최대

//입력 : N, M (1~100) / 이전 월봉 A_i (-2^10~2^10) -> int(-2^31~2^31) 가능

// [X] 완전 탐색 -> N = 100, M = 50이라면 조합의 수가 10^29
// [X] 그리디 알고리즘 -> 답이 다르게 나온다.
//                       1,2,3 중 2개를 골랐을 때 010^001 = 3(011)이 최대
//                       1,2,3 중 3개를 골랐을 때 001^001^011 = 3(011)이 최대여야 하는데,
//                       그리디 알고리즘을 활용하면 최대가 011^001 = 2(010)임.
// [!] 냅색 문제와 같이, 각 상태를 이전 상태의 값에 기반해 결과를 얻어내자. 'DP'

// 시간 복잡도 O(1024 * N * M)

#include <bits/stdc++.h>

using namespace std;

int N, M;
int arr[1010];

// 1. 상태 정의
int dp[1010][2020]; //i개를 골라서, j를 만들 수 있는지 여부

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    //입력
    cin >> N >> M; //이전 N개의 월봉 중, M개를 중복 허용해 고르자.
    for (int i=1 ; i <=N ; i++) {
        cin >> arr[i];
        arr[i] = abs(arr[i]); //절댓값만 필요하니까, abs 처리.
        // 2. 초기값 설정. 주어지는 값들에 대하여서는 1개 골라서 값을 만들 수 있다.
        dp[1][arr[i]] = 1;
    }

    //bitwise XOR 연산을 M-1번 진행한다.
    for (int i=2 ; i<=M ; i++) {
        for (int j=1 ; j<=N ; j++) {
            for (int k=0 ; k<1024 ; k++) {
                // 3. 점화식 구현 : i-1개의 월봉으로 k를 만들었다고 하자. (|= 의 오른쪽이 true가 된다.)
                // 여기서 j번째 월봉인 arr[j]를 XOR하여 얻어지는 k^arr[j]를 계산하여 얻을 수 있다.
                dp[i][k^arr[j]] |= dp[i-1][k];
            }
        }
    }

    //우리가 결과적으로 구하고자 하는
    //M개의 월봉을 선택했을 때의 결과인 i가 나타나는 true 중 가장 큰 값이 답이 된다.
    for (int i=1023 ; i>=0 ; i--) {
        if(dp[M][i]) {
            cout << i << endl;
            return 0; //가장 큰 값인 i 출력에 성공하면 프로그램을 멈춘다.
        }
    }
}