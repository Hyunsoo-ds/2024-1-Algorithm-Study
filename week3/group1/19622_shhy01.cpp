// N개의 회의와 하나의 회의실
// 각 회의는 시작 시간, 끝 시간, 회의 인원이 주어짐
// N개의 회의를 효율적으로 배정할 때, 회의를 진행할 수 있는 최대 인원을 구하자.


// 회의 수 N(1~100,000)이 주어지고,
// 각 회의별로 시작 시간, 끝 시간(0~2^31-1), 회의 인원(1~1,000)이 주어짐

// 회의 진행 인원이 최대가 되도록 주어진 회의 N개 중에서 일부 선택해야 한다.
// 어떤 회의를 선택했는가에 따른 결과를 쌓아 올려 문제를 해결하므로, DP를 써보자.

// [!] N이 100,000이므로, 단순 이분탐색으로 풀 수 없다.

// 1. 테이블 정의하기
//    D[i][2] = i번째 회의에 대하여, 회의를 진행하면 1 아니면 0
// 2. 점화식 찾기
//    D[i][0] = D[i-1][0] 혹은 D[i-1][1] 중에 큰 값.
//    D[i][1] = D[i-1][0] + i번째 회의의 인원 수
// 3. 초기값 정하기
//    D[1][0] = 0, D[1][1] = 첫번째 회의의 인원 수
//    D[2][0] = D[1][1], D[2][1] = 두번째 회의의 인원 수(첫번째 회의를 선택하지 못한다.)
    
#include <iostream>
#include <vector>

using namespace std;
using ll = long long;

//C++ vector를 pair 사용하여 쌍으로 값을 저장해보자.
#define X first
#define Y second

//1. 테이블 정의하기
ll dp[100001][2]; //n번째 회의에 대하여, 회의를 하면 1 아니면 0
vector<pair<pair<ll, ll>, ll>> ar;

int main(void) {

    ios::sync_with_stdio(false);
    cin.tie(0);

    ll n;
    cin >> n; //회의 개수

    ar.resize(n+1);
    for (int i=1; i<=n; i++) {
        //ar[i]는 i번째 회의의 시작 시간 / 끝 시간 / 회의 인원을 저장한다.
        cin >> ar[i].X.X >> ar[i].X.Y >> ar[i].Y;
    }

    //3. 초기값 지정
    //1번째를 회의를 선택한다면, 먼저 1번째 회의 인원을 넣는다.
    dp[1][1] = ar[1].Y;
    //2번째 회의 : 선택하지 않는다면 이전 회의 인원 그대로, 선택한다면 2번째 회의 인원을 넣는다.
    dp[2][0] = ar[1].Y; dp[2][1] = ar[2].Y;

    //2. 점화식 찾기
    for (int i = 3; i<=n ; i++) {
        //i번째 회의를 선택하지 않는다면, 이전까지의 최댓값을 넣는다.
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
        //i번째 회의를 선택한다면, i번째 회의의 인원 수를 더한다.
        dp[i][1] = dp[i-1][0] + ar[i].Y; //i-1번째 회의는 시간이 겹치기 때문에 선택하지 않았다는 선택지만 존재하기 때문에, dp[i-1][0]에 합한다.
    }
    
    cout << max(dp[n][0], dp[n][1]) << endl;
}